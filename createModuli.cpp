/* createModuli.cpp -- Program to generate moduli.h.

  Prepares a declaration for an array of moduli and ancillary data needed to compute inverses.

  See Cavagnino & Werbrouck
      Efficient Algorithms for Integer Division by Constants Using Multiplication
      The Computer Journal
      Vol. 51 No. 4, 2008.
      
  Based on initial work by
  Authors: Justin Brew, Anthony Rizzo, Kenneth Weber
           Mount Union College
           June 25, 2009
           
  Further revisions by 
  K. Weber  University of Mount Union
            weberk@mountunion.edu
            
  See GmpCudaDevice.cu for revision history.
*/

#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <stdint.h>
#include <gmp.h>
#include "GmpCudaDevice.h"

using namespace std;
using namespace GmpCuda;

//  Returns gcd(x, y).
//  Precondition: both x and y are odd.
static inline uint32_t gcd (uint32_t x, uint32_t y)
{
  while (x != y)
    {
      if (x > y)
        {
          x -= y;
          while (x % 2 == 0)
            x /= 2;
        }
      else
        {
          y -= x;
          while (y % 2 == 0)
            y /= 2;
        }
    }
  return x;
}

static void mark_composite(uint32_t limit, char* sieve, size_t sieve_sz)
{
  uint32_t d = static_cast<uint32_t>(floor(sqrt(static_cast<double>(limit))));

  if (d % 2 == 0)
    d -= 1;                /*  Make d odd.  */

  while (d > 2)
    {
      uint32_t g = gcd(d, uint32_t{3}*5*7*11*13*17*19*23*29);
      switch (g)
        {
        case  3: case  5: case  7: 
        case 11: case 13: case 17: 
        case 19: case 23: case 29:
          if (d != g)
            break;  // d is a multiple of small prime--ignore.
        case 1:
          size_t i = limit % d;
          if (i % 2)
            i += d;
          i /= 2;
          size_t end = (limit - d) / 2;
          if (sieve_sz < end)
            end = sieve_sz;
          while (i < end)
            sieve[i] = !0, i += d;
        }
      d -= 2;
    }
}

/*
    Generate a list of the N largest L-bit odd primes.  If there will
    not be enough values to generate the whole list whatever is
    generated will be returned in LIST; it is assumed that LIST has at
    least N slots.  The return value of the function is how many slots were
    left empty in LIST.  The larger primes will be placed at the lower
    indices of LIST.
*/

size_t primes(uint32_t * list, size_t n)
{
  static constexpr uint32_t SIEVE_SZ = 1 << (L - 2); //  Will handle all L-bit odd primes. 
  static char sieve[SIEVE_SZ];                
  uint32_t limit = (uint64_t{1} << L) - 1;
  uint32_t lowerLimit = 1 << (L - 1);
 
  if (n == 0 || limit < 3)
      return n;

  size_t sieve_sz = SIEVE_SZ;
  if (sieve_sz > limit/2)
      sieve_sz = limit/2;

  memset(sieve, 0, sieve_sz);

  mark_composite(limit, sieve, sieve_sz);

  /*  Harvest primes.  */
  for (size_t i = 0; i < sieve_sz; i++)
    {
      if (sieve[i])
        continue;                         /*  Composite.  */
      *list = limit - (i << 1);
      if (*list++ < lowerLimit)
        return n;
      n -= 1;
      if (n == 0)
        return n;
    }

  return n;
}

int main(int argc, char *argv[])
{
  cout   << "//  AUTOMATICALLY GENERATED by createModuli: do not edit" << endl
         << endl
         << "//  A list of " << L << "-bit primes, selected so that DBM_a(N, J) will always be accurate." << endl
         << "//  See Cavagnino & Werbrouck," << endl
         << "//      Efficient Algorithms for Integer Division by Constants Using Multiplication," << endl
         << "//      The Computer Journal, Vol. 51 No. 4, 2008." << endl
         << endl
         << "#include \"GmpCudaDevice.h\"" << endl
         << "__device__ const GmpCuda::modulus_t GmpCuda::moduliList[] = " << endl
         << "{" << endl;
  
  static constexpr size_t MAX_NUM_MODULI = 100 * 1000 * 1000;  //  There are around 98 million 32-bit moduli.
  static uint32_t moduliList[MAX_NUM_MODULI];
  mpz_t FC, J, DJ_FC, Qcr, Ncr;
  mpz_init_set_ui(FC,  2);
  mpz_pow_ui(FC, FC, W + L - 1);  //  FC <-- 2^(W + L - 1)
  mpz_init(J);
  mpz_init(DJ_FC);
  mpz_init(Qcr);
  mpz_init(Ncr);
  size_t numPrimes = MAX_NUM_MODULI - primes(moduliList, MAX_NUM_MODULI);
  size_t numUsable = 0;
  
  for (size_t i = 0; i < numPrimes; i += 1)
    {
      uint32_t D = moduliList[i];
      mpz_fdiv_q_ui(J, FC, D);
      mpz_add_ui(J, J, 1);          //  J <-- FC / D + 1
      mpz_mul_ui(DJ_FC, J, D);
      mpz_sub(DJ_FC, DJ_FC, FC);    //  DJ_FC <-- D * J - FC
      mpz_cdiv_q(Qcr, J, DJ_FC);    //  Qcr <-- ceil(J / DJ_FC)
      mpz_mul_ui(Ncr, Qcr, D);
      mpz_sub_ui(Ncr, Ncr, 1);      //  Ncr <-- Qcr * D - 1
      if (mpz_sizeinbase(Ncr, 2) > W)
        {
          uint64_t inverse;
          mpz_export(&inverse, NULL, -1, sizeof(uint64_t), 0, 0, J);
          numUsable += 1;
          if (numUsable <= NUM_MODULI)
            cout << "\t{" << moduliList[i] << ", " << inverse << "}," << endl;
        }
    }

  cout << "};" << endl;
  cerr << "There are " << numPrimes << " " << L << "-bit primes; "
       << numUsable << " are usable as moduli." << endl;
  if (numUsable >= NUM_MODULI)
    return 0;  
  cerr << "Error: "<< NUM_MODULI << " usable moduli are required." << endl;
  return 1;
  
}
